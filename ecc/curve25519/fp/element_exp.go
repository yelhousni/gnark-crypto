// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package fp

// expBySqrtExp is equivalent to z.Exp(x, ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd)
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) expBySqrtExp(x Element) *Element {
	// addition chain:
	//
	//	_10    = 2*1
	//	_11    = 1 + _10
	//	_1100  = _11 << 2
	//	_1111  = _11 + _1100
	//	_11110 = 2*_1111
	//	_11111 = 1 + _11110
	//	x10    = _11111 << 5 + _11111
	//	x15    = x10 << 5 + _11111
	//	x30    = x15 << 15 + x15
	//	x60    = x30 << 30 + x30
	//	x120   = x60 << 60 + x60
	//	x240   = x120 << 120 + x120
	//	x250   = x240 << 10 + x10
	//	return   x250 << 2 + 1
	//
	// Operations: 251 squares 11 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
	)

	// var t0,t1 Element
	// Step 1: z = x^0x2
	z.Square(&x)

	// Step 2: z = x^0x3
	z.Mul(&x, z)

	// Step 4: t0 = x^0xc
	t0.Square(z)
	for s := 1; s < 2; s++ {
		t0.Square(t0)
	}

	// Step 5: z = x^0xf
	z.Mul(z, t0)

	// Step 6: z = x^0x1e
	z.Square(z)

	// Step 7: t0 = x^0x1f
	t0.Mul(&x, z)

	// Step 12: z = x^0x3e0
	z.Square(t0)
	for s := 1; s < 5; s++ {
		z.Square(z)
	}

	// Step 13: z = x^0x3ff
	z.Mul(t0, z)

	// Step 18: t1 = x^0x7fe0
	t1.Square(z)
	for s := 1; s < 5; s++ {
		t1.Square(t1)
	}

	// Step 19: t0 = x^0x7fff
	t0.Mul(t0, t1)

	// Step 34: t1 = x^0x3fff8000
	t1.Square(t0)
	for s := 1; s < 15; s++ {
		t1.Square(t1)
	}

	// Step 35: t0 = x^0x3fffffff
	t0.Mul(t0, t1)

	// Step 65: t1 = x^0xfffffffc0000000
	t1.Square(t0)
	for s := 1; s < 30; s++ {
		t1.Square(t1)
	}

	// Step 66: t0 = x^0xfffffffffffffff
	t0.Mul(t0, t1)

	// Step 126: t1 = x^0xfffffffffffffff000000000000000
	t1.Square(t0)
	for s := 1; s < 60; s++ {
		t1.Square(t1)
	}

	// Step 127: t0 = x^0xffffffffffffffffffffffffffffff
	t0.Mul(t0, t1)

	// Step 247: t1 = x^0xffffffffffffffffffffffffffffff000000000000000000000000000000
	t1.Square(t0)
	for s := 1; s < 120; s++ {
		t1.Square(t1)
	}

	// Step 248: t0 = x^0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t0.Mul(t0, t1)

	// Step 258: t0 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00
	for s := 0; s < 10; s++ {
		t0.Square(t0)
	}

	// Step 259: z = x^0x3ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
	z.Mul(z, t0)

	// Step 261: z = x^0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc
	for s := 0; s < 2; s++ {
		z.Square(z)
	}

	// Step 262: z = x^0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd
	z.Mul(&x, z)

	return z
}

// expByLegendreExp is equivalent to z.Exp(x, 3ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6)
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) expByLegendreExp(x Element) *Element {
	// addition chain:
	//
	//	_10       = 2*1
	//	_11       = 1 + _10
	//	_1100     = _11 << 2
	//	_1111     = _11 + _1100
	//	_11110000 = _1111 << 4
	//	_11111111 = _1111 + _11110000
	//	x10       = _11111111 << 2 + _11
	//	x20       = x10 << 10 + x10
	//	x30       = x20 << 10 + x10
	//	x60       = x30 << 30 + x30
	//	x120      = x60 << 60 + x60
	//	x240      = x120 << 120 + x120
	//	x250      = x240 << 10 + x10
	//	return      2*(x250 << 3 + _11)
	//
	// Operations: 253 squares 11 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
		t2 = new(Element)
	)

	// var t0,t1,t2 Element
	// Step 1: z = x^0x2
	z.Square(&x)

	// Step 2: z = x^0x3
	z.Mul(&x, z)

	// Step 4: t0 = x^0xc
	t0.Square(z)
	for s := 1; s < 2; s++ {
		t0.Square(t0)
	}

	// Step 5: t0 = x^0xf
	t0.Mul(z, t0)

	// Step 9: t1 = x^0xf0
	t1.Square(t0)
	for s := 1; s < 4; s++ {
		t1.Square(t1)
	}

	// Step 10: t0 = x^0xff
	t0.Mul(t0, t1)

	// Step 12: t0 = x^0x3fc
	for s := 0; s < 2; s++ {
		t0.Square(t0)
	}

	// Step 13: t0 = x^0x3ff
	t0.Mul(z, t0)

	// Step 23: t1 = x^0xffc00
	t1.Square(t0)
	for s := 1; s < 10; s++ {
		t1.Square(t1)
	}

	// Step 24: t1 = x^0xfffff
	t1.Mul(t0, t1)

	// Step 34: t1 = x^0x3ffffc00
	for s := 0; s < 10; s++ {
		t1.Square(t1)
	}

	// Step 35: t1 = x^0x3fffffff
	t1.Mul(t0, t1)

	// Step 65: t2 = x^0xfffffffc0000000
	t2.Square(t1)
	for s := 1; s < 30; s++ {
		t2.Square(t2)
	}

	// Step 66: t1 = x^0xfffffffffffffff
	t1.Mul(t1, t2)

	// Step 126: t2 = x^0xfffffffffffffff000000000000000
	t2.Square(t1)
	for s := 1; s < 60; s++ {
		t2.Square(t2)
	}

	// Step 127: t1 = x^0xffffffffffffffffffffffffffffff
	t1.Mul(t1, t2)

	// Step 247: t2 = x^0xffffffffffffffffffffffffffffff000000000000000000000000000000
	t2.Square(t1)
	for s := 1; s < 120; s++ {
		t2.Square(t2)
	}

	// Step 248: t1 = x^0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t1.Mul(t1, t2)

	// Step 258: t1 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00
	for s := 0; s < 10; s++ {
		t1.Square(t1)
	}

	// Step 259: t0 = x^0x3ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t0.Mul(t0, t1)

	// Step 262: t0 = x^0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8
	for s := 0; s < 3; s++ {
		t0.Square(t0)
	}

	// Step 263: z = x^0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb
	z.Mul(z, t0)

	// Step 264: z = x^0x3ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6
	z.Square(z)

	return z
}
