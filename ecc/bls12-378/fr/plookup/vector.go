// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package plookup

import (
	"crypto/sha256"
	"errors"
	"math/big"
	"math/bits"
	"sort"

	"github.com/consensys/gnark-crypto/ecc/bls12-378/fr"
	"github.com/consensys/gnark-crypto/ecc/bls12-378/fr/fft"
	"github.com/consensys/gnark-crypto/ecc/bls12-378/fr/kzg"
	"github.com/consensys/gnark-crypto/ecc/bls12-378/fr/polynomial"
	fiatshamir "github.com/consensys/gnark-crypto/fiat-shamir"
)

var (
	ErrNotInTable          = errors.New("some value in the vector is not in the lookup table")
	ErrPlookupVerification = errors.New("plookup verification failed")
)

type Table []fr.Element

// Len is the number of elements in the collection.
func (t Table) Len() int {
	return len(t)
}

// Less reports whether the element with
// index i should sort before the element with index j.
func (t Table) Less(i, j int) bool {
	return t[i].Cmp(&t[j]) == -1
}

// Swap swaps the elements with indexes i and j.
func (t Table) Swap(i, j int) {
	t[i], t[j] = t[j], t[i]
}

// Proof Plookup proof, containing opening proofs
type ProofLookupVector struct {

	// size of the system
	size uint64

	// Commitments to h1, h2, t, z, f, h
	h1, h2, t, z, f, h kzg.Digest

	// Batch opening proof of h1, h2, z, t
	BatchedProof kzg.BatchOpeningProof

	// Batch opening proof of h1, h2, z shifted by g
	BatchedProofShifted kzg.BatchOpeningProof
}

// computeZ computes Z, in Lagrange basis. Z is the accumulation of the partial
// ratios of 2 fully split polynomials (cf https://eprint.iacr.org/2020/315.pdf)
// * lf is the list of values that should be in lt
// * lt is the lookup table
// * lh1, lh2 is lf sorted by lt split in 2 overlapping slices
// * beta, gamma are challenges (Schwartz-zippel: they are the random evaluations point)
func computeZ(lf, lt, lh1, lh2 []fr.Element, beta, gamma fr.Element) []fr.Element {

	z := make([]fr.Element, len(lt))

	n := len(lt)
	d := make([]fr.Element, n-1)
	var u, c fr.Element
	c.SetOne().
		Add(&c, &beta).
		Mul(&c, &gamma)
	for i := 0; i < n-1; i++ {

		d[i].Mul(&beta, &lh1[i+1]).
			Add(&d[i], &lh1[i]).
			Add(&d[i], &c)

		u.Mul(&beta, &lh2[i+1]).
			Add(&u, &lh2[i]).
			Add(&u, &c)

		d[i].Mul(&d[i], &u)
	}
	d = fr.BatchInvert(d)

	z[0].SetOne()
	var a, b, e fr.Element
	e.SetOne().Add(&e, &beta)
	for i := 0; i < n-1; i++ {

		a.Add(&gamma, &lf[i])

		b.Mul(&beta, &lt[i+1]).
			Add(&b, &lt[i]).
			Add(&b, &c)

		a.Mul(&a, &b).
			Mul(&a, &e)

		z[i+1].Mul(&z[i], &a).
			Mul(&z[i+1], &d[i])
	}

	return z
}

// computeH computes the evaluation (shifted, bit reversed) of h where
// h = (x-1)*z*(1+beta)*(gamma+f)*(gamma(1+beta) + t+ beta*t(gX)) -
//		(x-1)*z(gX)*(gamma(1+beta) + h1 + beta*h1(gX))*(gamma(1+beta) + h2 + beta*h2(gX) )
//
// * cz, ch1, ch2, ct, cf are the polynomials z, h1, h2, t, f in canonical basis
// * _lz, _lh1, _lh2, _lt, _lf are the polynomials z, h1, h2, t, f in shifted Lagrange basis (domainH)
// * beta, gamma are the challenges
// * it returns h in canonical basis
func computeH(_lz, _lh1, _lh2, _lt, _lf []fr.Element, beta, gamma fr.Element, domainH *fft.Domain) []fr.Element {

	// result
	s := int(domainH.Cardinality)
	num := make([]fr.Element, domainH.Cardinality)

	var u, v, w, _g, m, n, one, t fr.Element
	t.SetUint64(2).
		Inverse(&t)
	_g.Square(&domainH.Generator).
		Exp(_g, big.NewInt(int64(s/2-1)))
	one.SetOne()
	v.Add(&one, &beta)
	w.Mul(&v, &gamma)

	g := make([]fr.Element, s)
	g[0].Set(&domainH.FinerGenerator)
	for i := 1; i < s; i++ {
		g[i].Mul(&g[i-1], &domainH.Generator)
	}

	nn := uint64(64 - bits.TrailingZeros64(domainH.Cardinality))

	for i := 0; i < s; i++ {

		_i := int(bits.Reverse64(uint64(i)) >> nn)
		_is := int(bits.Reverse64(uint64((i+2)%s)) >> nn)

		// m = (x-g**(n-1))*z*(1+beta)*(gamma+f)*(gamma(1+beta) + t+ beta*t(gX))
		m.Mul(&v, &_lz[_i])
		u.Add(&gamma, &_lf[_i])
		m.Mul(&m, &u)
		u.Mul(&beta, &_lt[_is]).
			Add(&u, &_lt[_i]).
			Add(&u, &w)
		m.Mul(&m, &u)

		// n = (x-g**(n-1))*z(gX)*(gamma(1+beta) + h1 + beta*h1(gX))*(gamma(1+beta) + h2 + beta*h2(gX)
		n.Mul(&beta, &_lh1[_is]).
			Add(&n, &_lh1[_i]).
			Add(&n, &w)
		u.Mul(&beta, &_lh2[_is]).
			Add(&u, &_lh2[_i]).
			Add(&u, &w)
		n.Mul(&n, &u).
			Mul(&n, &_lz[_is])

		num[_i].Sub(&m, &n)
		u.Sub(&g[i], &_g)
		num[_i].Mul(&num[_i], &u)

	}

	return num
}

// computeH0 returns l0 * (z-1), in Lagrange basis and bit reversed order
func computeH0(lzCosetReversed []fr.Element, domainH *fft.Domain) []fr.Element {

	var one fr.Element
	one.SetOne()

	var g [2]fr.Element
	g[0].Exp(domainH.FinerGenerator, big.NewInt(int64(domainH.Cardinality/2)))
	g[1].Neg(&g[0])
	g[0].Sub(&g[0], &one)
	g[1].Sub(&g[1], &one)

	var d fr.Element
	d.Set(&domainH.FinerGenerator)
	den := make([]fr.Element, len(lzCosetReversed))
	for i := 0; i < len(den); i++ {
		den[i].Sub(&d, &one)
		d.Mul(&d, &domainH.Generator)
	}
	den = fr.BatchInvert(den)

	res := make([]fr.Element, len(lzCosetReversed))
	nn := uint64(64 - bits.TrailingZeros64(domainH.Cardinality))

	for i := 0; i < len(lzCosetReversed); i++ {
		_i := int(bits.Reverse64(uint64(i)) >> nn)
		res[_i].Sub(&lzCosetReversed[_i], &one).
			Mul(&res[_i], &g[i%2]).Mul(&res[_i], &den[i])
	}

	return res
}

// computeHn returns ln * (z-1), in Lagrange basis and bit reversed order
func computeHn(lzCosetReversed []fr.Element, domainH *fft.Domain) []fr.Element {

	var one fr.Element
	one.SetOne()

	var g [2]fr.Element
	g[0].Exp(domainH.FinerGenerator, big.NewInt(int64(domainH.Cardinality/2)))
	g[1].Neg(&g[0])
	g[0].Sub(&g[0], &one)
	g[1].Sub(&g[1], &one)

	var _g, d fr.Element
	one.SetOne()
	d.Set(&domainH.FinerGenerator)
	_g.Square(&domainH.Generator).Exp(_g, big.NewInt(int64(domainH.Cardinality/2-1)))
	den := make([]fr.Element, len(lzCosetReversed))
	for i := 0; i < len(lzCosetReversed); i++ {
		den[i].Sub(&d, &_g)
		d.Mul(&d, &domainH.Generator)
	}
	den = fr.BatchInvert(den)

	res := make([]fr.Element, len(lzCosetReversed))
	nn := uint64(64 - bits.TrailingZeros64(domainH.Cardinality))

	for i := 0; i < len(lzCosetReversed); i++ {
		_i := int(bits.Reverse64(uint64(i)) >> nn)
		res[_i].Sub(&lzCosetReversed[_i], &one).
			Mul(&res[_i], &g[i%2]).
			Mul(&res[_i], &den[i])
	}

	return res
}

// computeHh1h2 returns ln * (h1 - h2(g.x)), in Lagrange basis and bit reversed order
func computeHh1h2(_lh1, _lh2 []fr.Element, domainH *fft.Domain) []fr.Element {

	var one fr.Element
	one.SetOne()

	var g [2]fr.Element
	g[0].Exp(domainH.FinerGenerator, big.NewInt(int64(domainH.Cardinality/2)))
	g[1].Neg(&g[0])
	g[0].Sub(&g[0], &one)
	g[1].Sub(&g[1], &one)

	var _g, d fr.Element
	d.Set(&domainH.FinerGenerator)
	_g.Square(&domainH.Generator).Exp(_g, big.NewInt(int64(domainH.Cardinality/2-1)))
	den := make([]fr.Element, len(_lh1))
	for i := 0; i < len(_lh1); i++ {
		den[i].Sub(&d, &_g)
		d.Mul(&d, &domainH.Generator)
	}
	den = fr.BatchInvert(den)

	res := make([]fr.Element, len(_lh1))
	nn := uint64(64 - bits.TrailingZeros64(domainH.Cardinality))

	s := len(_lh1)
	for i := 0; i < s; i++ {

		_i := int(bits.Reverse64(uint64(i)) >> nn)
		_is := int(bits.Reverse64(uint64((i+2)%s)) >> nn)

		res[_i].Sub(&_lh1[_i], &_lh2[_is]).
			Mul(&res[_i], &g[i%2]).
			Mul(&res[_i], &den[i])
	}

	return res
}

// computeQuotient computes the full quotient of the plookup protocol.
// * alpha is the challenge to fold the numerator
// * lh, lh0, lhn, lh1h2 are the various pieces of the numerator (Lagrange shifted form, bit reversed order)
// * domainH fft domain
// It returns the quotient, in canonical basis
func computeQuotient(alpha fr.Element, lh, lh0, lhn, lh1h2 []fr.Element, domainH *fft.Domain) []fr.Element {

	s := len(lh)
	res := make([]fr.Element, s)

	var one fr.Element
	one.SetOne()

	var d [2]fr.Element
	d[0].Exp(domainH.FinerGenerator, big.NewInt(int64(domainH.Cardinality>>1)))
	d[1].Neg(&d[0])
	d[0].Sub(&d[0], &one).Inverse(&d[0])
	d[1].Sub(&d[1], &one).Inverse(&d[1])

	nn := uint64(64 - bits.TrailingZeros64(domainH.Cardinality))

	for i := 0; i < s; i++ {

		_i := int(bits.Reverse64(uint64(i)) >> nn)

		res[_i].Mul(&lh1h2[_i], &alpha).
			Add(&res[_i], &lhn[_i]).
			Mul(&res[_i], &alpha).
			Add(&res[_i], &lh0[_i]).
			Mul(&res[_i], &alpha).
			Add(&res[_i], &lh[_i]).
			Mul(&res[_i], &d[i%2])
	}

	domainH.FFTInverse(res, fft.DIT, 1)

	return res
}

// ProveLookupVector returns proof that the values in f are in t.
//
// /!\IMPORTANT/!\
//
// If the table t is already commited somewhere (which is the normal workflow
// before generating a lookup proof), the commitment needs to be done on the
// table sorted. Otherwise the commitment in proof.t will not be the same as
// the public commitment: it will contain the same values, but permuted.
//
func ProveLookupVector(srs *kzg.SRS, f, t Table) (ProofLookupVector, error) {

	// res
	var proof ProofLookupVector
	var err error

	// hash function used for Fiat Shamir
	hFunc := sha256.New()

	// transcript to derive the challenge
	fs := fiatshamir.NewTranscript(hFunc, "beta", "gamma", "alpha", "nu")

	// create domains
	var dNum *fft.Domain
	if len(t) <= len(f) {
		dNum = fft.NewDomain(uint64(len(f)+1), 0, false)
	} else {
		dNum = fft.NewDomain(uint64(len(t)), 0, false)
	}
	cardDNum := int(dNum.Cardinality)

	// set the size
	proof.size = dNum.Cardinality

	// resize f and t
	// note: the last element of lf does not matter
	lf := make([]fr.Element, cardDNum)
	lt := make([]fr.Element, cardDNum)
	cf := make([]fr.Element, cardDNum)
	ct := make([]fr.Element, cardDNum)
	copy(lt, t)
	copy(lf, f)
	for i := len(f); i < cardDNum; i++ {
		lf[i] = f[len(f)-1]
	}
	for i := len(t); i < cardDNum; i++ {
		lt[i] = t[len(t)-1]
	}
	sort.Sort(Table(lt))
	copy(ct, lt)
	copy(cf, lf)
	dNum.FFTInverse(ct, fft.DIF, 0)
	dNum.FFTInverse(cf, fft.DIF, 0)
	fft.BitReverse(ct)
	fft.BitReverse(cf)
	proof.t, err = kzg.Commit(ct, srs)
	if err != nil {
		return proof, err
	}
	proof.f, err = kzg.Commit(cf, srs)
	if err != nil {
		return proof, err
	}

	// write f sorted by t
	lfSortedByt := make(Table, 2*dNum.Cardinality-1)
	copy(lfSortedByt, lt)
	copy(lfSortedByt[dNum.Cardinality:], lf)
	sort.Sort(lfSortedByt)

	// compute h1, h2, commit to them
	lh1 := make([]fr.Element, cardDNum)
	lh2 := make([]fr.Element, cardDNum)
	ch1 := make([]fr.Element, cardDNum)
	ch2 := make([]fr.Element, cardDNum)
	copy(lh1, lfSortedByt[:cardDNum])
	copy(lh2, lfSortedByt[cardDNum-1:])

	copy(ch1, lfSortedByt[:cardDNum])
	copy(ch2, lfSortedByt[cardDNum-1:])
	dNum.FFTInverse(ch1, fft.DIF, 0)
	dNum.FFTInverse(ch2, fft.DIF, 0)
	fft.BitReverse(ch1)
	fft.BitReverse(ch2)

	proof.h1, err = kzg.Commit(ch1, srs)
	if err != nil {
		return proof, err
	}
	proof.h2, err = kzg.Commit(ch2, srs)
	if err != nil {
		return proof, err
	}

	// derive beta, gamma
	beta, err := deriveRandomness(&fs, "beta", &proof.t, &proof.f, &proof.h1, &proof.h2)
	if err != nil {
		return proof, err
	}
	gamma, err := deriveRandomness(&fs, "gamma")
	if err != nil {
		return proof, err
	}

	// Compute to Z
	lz := computeZ(lf, lt, lh1, lh2, beta, gamma)
	cz := make([]fr.Element, len(lz))
	copy(cz, lz)
	dNum.FFTInverse(cz, fft.DIF, 0)
	fft.BitReverse(cz)
	proof.z, err = kzg.Commit(cz, srs)
	if err != nil {
		return proof, err
	}

	// prepare data for computing the quotient
	// compute the numerator
	s := dNum.Cardinality
	domainH := fft.NewDomain(uint64(2*s), 1, false)
	_lz := make([]fr.Element, 2*s)
	_lh1 := make([]fr.Element, 2*s)
	_lh2 := make([]fr.Element, 2*s)
	_lt := make([]fr.Element, 2*s)
	_lf := make([]fr.Element, 2*s)
	copy(_lz, cz)
	copy(_lh1, ch1)
	copy(_lh2, ch2)
	copy(_lt, ct)
	copy(_lf, cf)
	domainH.FFT(_lz, fft.DIF, 1)
	domainH.FFT(_lh1, fft.DIF, 1)
	domainH.FFT(_lh2, fft.DIF, 1)
	domainH.FFT(_lt, fft.DIF, 1)
	domainH.FFT(_lf, fft.DIF, 1)

	// compute h
	lh := computeH(_lz, _lh1, _lh2, _lt, _lf, beta, gamma, domainH)

	// compute h0
	lh0 := computeH0(_lz, domainH)

	// compute hn
	lhn := computeHn(_lz, domainH)

	// compute hh1h2
	lh1h2 := computeHh1h2(_lh1, _lh2, domainH)

	// compute the quotient
	alpha, err := deriveRandomness(&fs, "alpha", &proof.z)
	if err != nil {
		return proof, err
	}
	ch := computeQuotient(alpha, lh, lh0, lhn, lh1h2, domainH)
	proof.h, err = kzg.Commit(ch, srs)
	if err != nil {
		return proof, err
	}

	// build the opening proofs
	nu, err := deriveRandomness(&fs, "nu", &proof.h)
	if err != nil {
		return proof, err
	}
	proof.BatchedProof, err = kzg.BatchOpenSinglePoint(
		[]polynomial.Polynomial{
			ch1,
			ch2,
			ct,
			cz,
			cf,
			ch,
		},
		[]kzg.Digest{
			proof.h1,
			proof.h2,
			proof.t,
			proof.z,
			proof.f,
			proof.h,
		},
		&nu,
		hFunc,
		dNum,
		srs,
	)
	if err != nil {
		return proof, err
	}

	nu.Mul(&nu, &dNum.Generator)
	proof.BatchedProofShifted, err = kzg.BatchOpenSinglePoint(
		[]polynomial.Polynomial{
			ch1,
			ch2,
			ct,
			cz,
		},
		[]kzg.Digest{
			proof.h1,
			proof.h2,
			proof.t,
			proof.z,
		},
		&nu,
		hFunc,
		dNum,
		srs,
	)
	if err != nil {
		return proof, err
	}

	return proof, nil
}

// VerifyLookupVector verifies that a ProofLookupVector proof is correct
func VerifyLookupVector(srs *kzg.SRS, proof ProofLookupVector) error {

	// hash function that is used for Fiat Shamir
	hFunc := sha256.New()

	// transcript to derive the challenge
	fs := fiatshamir.NewTranscript(hFunc, "beta", "gamma", "alpha", "nu")

	// derive the various challenges
	beta, err := deriveRandomness(&fs, "beta", &proof.t, &proof.f, &proof.h1, &proof.h2)
	if err != nil {
		return err
	}

	gamma, err := deriveRandomness(&fs, "gamma")
	if err != nil {
		return err
	}

	alpha, err := deriveRandomness(&fs, "alpha", &proof.z)
	if err != nil {
		return err
	}

	nu, err := deriveRandomness(&fs, "nu", &proof.h)
	if err != nil {
		return err
	}

	// check opening proofs
	err = kzg.BatchVerifySinglePoint(
		[]kzg.Digest{
			proof.h1,
			proof.h2,
			proof.t,
			proof.z,
			proof.f,
			proof.h,
		},
		&proof.BatchedProof,
		hFunc,
		srs,
	)
	if err != nil {
		return err
	}

	err = kzg.BatchVerifySinglePoint(
		[]kzg.Digest{
			proof.h1,
			proof.h2,
			proof.t,
			proof.z,
		},
		&proof.BatchedProofShifted,
		hFunc,
		srs,
	)
	if err != nil {
		return err
	}

	// check polynomial relation using Schwartz Zippel
	var lhs, rhs, nun, g, _g, a, v, w, one fr.Element
	d := fft.NewDomain(proof.size, 0, false) // only there to access to root of 1...
	one.SetOne()
	g.Exp(d.Generator, big.NewInt(int64(d.Cardinality-1)))

	v.Add(&one, &beta)
	w.Mul(&v, &gamma)

	// h(nu) where
	// h = (x-1)*z*(1+beta)*(gamma+f)*(gamma(1+beta) + t+ beta*t(gX)) -
	//		(x-1)*z(gX)*(gamma(1+beta) + h1 + beta*h1(gX))*(gamma(1+beta) + h2 + beta*h2(gX) )
	lhs.Sub(&nu, &g).
		Mul(&lhs, &proof.BatchedProof.ClaimedValues[3]).
		Mul(&lhs, &v)
	a.Add(&gamma, &proof.BatchedProof.ClaimedValues[4])
	lhs.Mul(&lhs, &a)
	a.Mul(&beta, &proof.BatchedProofShifted.ClaimedValues[2]).
		Add(&a, &proof.BatchedProof.ClaimedValues[2]).
		Add(&a, &w)
	lhs.Mul(&lhs, &a)

	rhs.Sub(&nu, &g).
		Mul(&rhs, &proof.BatchedProofShifted.ClaimedValues[3])
	a.Mul(&beta, &proof.BatchedProofShifted.ClaimedValues[0]).
		Add(&a, &proof.BatchedProof.ClaimedValues[0]).
		Add(&a, &w)
	rhs.Mul(&rhs, &a)
	a.Mul(&beta, &proof.BatchedProofShifted.ClaimedValues[1]).
		Add(&a, &proof.BatchedProof.ClaimedValues[1]).
		Add(&a, &w)
	rhs.Mul(&rhs, &a)

	lhs.Sub(&lhs, &rhs)

	// check consistancy of bounds
	var l0, ln, d1, d2 fr.Element
	l0.Exp(nu, big.NewInt(int64(d.Cardinality))).Sub(&l0, &one)
	ln.Set(&l0)
	d1.Sub(&nu, &one)
	d2.Sub(&nu, &g)
	l0.Div(&l0, &d1)
	ln.Div(&ln, &d2)

	// l0*(z-1)
	var l0z fr.Element
	l0z.Sub(&proof.BatchedProof.ClaimedValues[3], &one).
		Mul(&l0z, &l0)

	// ln*(z-1)
	var lnz fr.Element
	lnz.Sub(&proof.BatchedProof.ClaimedValues[3], &one).
		Mul(&ln, &lnz)

	// ln*(h1 - h2(g.x))
	var lnh1h2 fr.Element
	lnh1h2.Sub(&proof.BatchedProof.ClaimedValues[0], &proof.BatchedProofShifted.ClaimedValues[1]).
		Mul(&lnh1h2, &ln)

	// fold the numerator
	lnh1h2.Mul(&lnh1h2, &alpha).
		Add(&lnh1h2, &lnz).
		Mul(&lnh1h2, &alpha).
		Add(&lnh1h2, &l0z).
		Mul(&lnh1h2, &alpha).
		Add(&lnh1h2, &lhs)

	// (x**n-1) * h(x) evaluated at nu
	nun.Exp(nu, big.NewInt(int64(d.Cardinality)))
	_g.Sub(&nun, &one)
	_g.Mul(&proof.BatchedProof.ClaimedValues[5], &_g)
	if !lnh1h2.Equal(&_g) {
		return ErrPlookupVerification
	}

	return nil
}
