// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package cp8632

import (
	"fmt"
	"math/big"
	"testing"

	"github.com/consensys/gnark-crypto/ecc/cp8-632/fp"

	"github.com/consensys/gnark-crypto/ecc/cp8-632/fr"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/prop"
)

/*
func TestG1AffineEndomorphism(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 10

	properties := gopter.NewProperties(parameters)

	properties.Property("[CP8-632] check that phi(P) = lambdaGLV * P", prop.ForAll(
		func(a fp.Element) bool {
			var p, res1, res2 G1W12
			g := MapToCurveG1Svdw(a)
			p.FromAffine(&g)
			res1.phi(&p)
			res2.mulWindowed(&p, &lambdaGLV)

			return p.IsInSubGroup() && res1.Equal(&res2)
		},
		GenFp(),
	))

	properties.Property("[CP8-632] check that phi^2(P) + phi(P) + P = 0", prop.ForAll(
		func(a fp.Element) bool {
			var p, res, tmp G1W12
			g := MapToCurveG1Svdw(a)
			p.FromAffine(&g)
			tmp.phi(&p)
			res.phi(&tmp).
				AddAssign(&tmp).
				AddAssign(&p)

			return res.Z.IsZero()
		},
		GenFp(),
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestMapToCurveG1(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 10

	properties := gopter.NewProperties(parameters)

	properties.Property("[G1] Svsw mapping should output point on the curve", prop.ForAll(
		func(a fp.Element) bool {
			g := MapToCurveG1Svdw(a)
			return g.IsInSubGroup()
		},
		GenFp(),
	))

	properties.Property("[G1] Svsw mapping should be deterministic", prop.ForAll(
		func(a fp.Element) bool {
			g1 := MapToCurveG1Svdw(a)
			g2 := MapToCurveG1Svdw(a)
			return g1.Equal(&g2)
		},
		GenFp(),
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}
*/

func TestG1AffineIsOnCurve(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 10

	properties := gopter.NewProperties(parameters)

	properties.Property("[CP8-632] g1Gen (affine) should be on the curve", prop.ForAll(
		func(a fp.Element) bool {
			var op1, op2 G1Affine
			op1.FromW12(&g1Gen)
			op2.FromW12(&g1Gen)
			op2.Y.Mul(&op2.Y, &a)
			return op1.IsOnCurve() && !op2.IsOnCurve()
		},
		GenFp(),
	))

	properties.Property("[CP8-632] g1Gen (W12) should be on the curve", prop.ForAll(
		func(a fp.Element) bool {
			var op1, op2, op3 G1W12
			op1.Set(&g1Gen)
			op3.Set(&g1Gen)

			op2 = fuzzW12G1Affine(&g1Gen, a)
			op3.Y.Mul(&op3.Y, &a)
			return op1.IsOnCurve() && op2.IsOnCurve() && !op3.IsOnCurve()
		},
		GenFp(),
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestG1AffineConversions(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)

	properties.Property("[CP8-632] Affine representation should be independent of the W12 representative", prop.ForAll(
		func(a fp.Element) bool {
			g := fuzzW12G1Affine(&g1Gen, a)
			var op1 G1Affine
			op1.FromW12(&g)
			return op1.X.Equal(&g1Gen.X) && op1.Y.Equal(&g1Gen.Y)
		},
		GenFp(),
	))

	properties.Property("[CP8-632] W12 representation should be the same as the affine representative", prop.ForAll(
		func(a fp.Element) bool {
			var g G1W12
			var op1 G1Affine
			op1.X.Set(&g1Gen.X)
			op1.Y.Set(&g1Gen.Y)

			var one fp.Element
			one.SetOne()

			g.FromAffine(&op1)

			return g.X.Equal(&g1Gen.X) && g.Y.Equal(&g1Gen.Y) && g.Z.Equal(&one)
		},
		GenFp(),
	))

	properties.Property("[CP8-632] Converting affine symbol for infinity to W12 should output correct infinity in W12", prop.ForAll(
		func() bool {
			var g G1Affine
			g.X.SetZero()
			g.Y.SetZero()
			var op1 G1W12
			op1.FromAffine(&g)
			var one, zero fp.Element
			one.SetOne()
			return op1.X.Equal(&zero) && op1.Y.Equal(&one) && op1.Z.Equal(&zero)
		},
	))

	properties.Property("[CP8-632] [W12] Two representatives of the same class should be equal", prop.ForAll(
		func(a, b fp.Element) bool {
			op1 := fuzzW12G1Affine(&g1Gen, a)
			op2 := fuzzW12G1Affine(&g1Gen, b)
			return op1.Equal(&op2)
		},
		GenFp(),
		GenFp(),
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestG1AffineOps(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 10

	properties := gopter.NewProperties(parameters)

	genScalar := GenFr()

	properties.Property("[CP8-632] [W12] Adding the opposite of a point to itself should output inf", prop.ForAll(
		func(a, b fp.Element) bool {
			fop1 := fuzzW12G1Affine(&g1Gen, a)
			fop2 := fuzzW12G1Affine(&g1Gen, b)
			fop2.Neg(&fop2)
			fop1.AddAssign(&fop2)
			return fop1.Equal(&g1Infinity)
		},
		GenFp(),
		GenFp(),
	))

	properties.Property("[CP8-632] [W12] Adding the inf to a point should not modify the point", prop.ForAll(
		func(a fp.Element) bool {
			fop1 := fuzzW12G1Affine(&g1Gen, a)
			fop1.AddAssign(&g1Infinity)
			var op2 G1W12
			op2.Set(&g1Infinity)
			op2.AddAssign(&g1Gen)
			return fop1.Equal(&g1Gen) && op2.Equal(&g1Gen)
		},
		GenFp(),
	))

	properties.Property("[CP8-632] [W12] Addmix the negation to itself should output 0", prop.ForAll(
		func(a fp.Element) bool {
			fop1 := fuzzW12G1Affine(&g1Gen, a)
			fop1.Neg(&fop1)
			var op2 G1Affine
			op2.FromW12(&g1Gen)
			fop1.AddMixed(&op2)
			return fop1.Equal(&g1Infinity)
		},
		GenFp(),
	))

	properties.Property("[CP8-632] [W12] Add the same point and double should be the same", prop.ForAll(
		func(a fp.Element) bool {
			p := fuzzW12G1Affine(&g1Gen, a)
            var q G1W12
            q.Double(&p)
            p.AddAssign(&p)

			return p.Equal(&q)
		},
		GenFp(),
	))

	properties.Property("[CP8-632] scalar multiplication (double and add) should depend only on the scalar mod r", prop.ForAll(
		func(s fr.Element) bool {

			r := fr.Modulus()
			var g G1W12
			g.ScalarMultiplication(&g1Gen, r)

			var scalar, blindedScalard, rminusone big.Int
			var op1, op2, op3, gneg G1W12
			rminusone.SetUint64(1).Sub(r, &rminusone)
			op3.ScalarMultiplication(&g1Gen, &rminusone)
			gneg.Neg(&g1Gen)
			s.ToBigIntRegular(&scalar)
			blindedScalard.Add(&scalar, r)
			op1.ScalarMultiplication(&g1Gen, &scalar)
			op2.ScalarMultiplication(&g1Gen, &blindedScalard)

			return op1.Equal(&op2) && g.Equal(&g1Infinity) && !op1.Equal(&g1Infinity) && gneg.Equal(&op3)

		},
		genScalar,
	))

    /*
	properties.Property("[CP8-632] scalar multiplication (GLV) should depend only on the scalar mod r", prop.ForAll(
		func(s fr.Element) bool {

			r := fr.Modulus()
			var g G1W12
			g.mulGLV(&g1Gen, r)

			var scalar, blindedScalard, rminusone big.Int
			var op1, op2, op3, gneg G1W12
			rminusone.SetUint64(1).Sub(r, &rminusone)
			op3.mulGLV(&g1Gen, &rminusone)
			gneg.Neg(&g1Gen)
			s.ToBigIntRegular(&scalar)
			blindedScalard.Add(&scalar, r)
			op1.mulGLV(&g1Gen, &scalar)
			op2.mulGLV(&g1Gen, &blindedScalard)

			return op1.Equal(&op2) && g.Equal(&g1Infinity) && !op1.Equal(&g1Infinity) && gneg.Equal(&op3)

		},
		genScalar,
	))

	properties.Property("[CP8-632] GLV and Double and Add should output the same result", prop.ForAll(
		func(s fr.Element) bool {

			var r big.Int
			var op1, op2 G1W12
			s.ToBigIntRegular(&r)
			op1.mulWindowed(&g1Gen, &r)
			op2.mulGLV(&g1Gen, &r)
			return op1.Equal(&op2) && !op1.Equal(&g1Infinity)

		},
		genScalar,
	))
    */

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestG1AffineCofactorCleaning(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 10

	properties := gopter.NewProperties(parameters)

	properties.Property("[CP8-632] Clearing the cofactor of a random point should set it in the r-torsion", prop.ForAll(
		func() bool {
			var a, x, b fp.Element
			a.SetRandom()

			x.Square(&a).Mul(&x, &a).Add(&x, &aCurveCoeff)

			for x.Legendre() != 1 {
				a.SetRandom()

				x.Square(&a).Mul(&x, &a).Add(&x, &aCurveCoeff)

			}

			b.Sqrt(&x)
			var point, pointCleared, infinity G1W12
			point.X.Set(&a)
			point.Y.Set(&b)
			point.Z.SetOne()
			pointCleared.ClearCofactor(&point)
			infinity.Set(&g1Infinity)
			return point.IsOnCurve() && pointCleared.IsInSubGroup() && !pointCleared.Equal(&infinity)
		},
	))
	properties.TestingRun(t, gopter.ConsoleReporter(false))

}

func TestG1AffineBatchScalarMultiplication(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 10

	properties := gopter.NewProperties(parameters)

	genScalar := GenFr()

	// size of the multiExps
	const nbSamples = 10

	properties.Property("[CP8-632] BatchScalarMultiplication should be consistant with individual scalar multiplications", prop.ForAll(
		func(mixer fr.Element) bool {
			// mixer ensures that all the words of a fpElement are set
			var sampleScalars [nbSamples]fr.Element

			for i := 1; i <= nbSamples; i++ {
				sampleScalars[i-1].SetUint64(uint64(i)).
					Mul(&sampleScalars[i-1], &mixer).
					FromMont()
			}

			result := BatchScalarMultiplicationG1(&g1GenAff, sampleScalars[:])

			if len(result) != len(sampleScalars) {
				return false
			}

			for i := 0; i < len(result); i++ {
				var expectedJac G1W12
				var expected G1Affine
				var b big.Int
				expectedJac.mulWindowed(&g1Gen, sampleScalars[i].ToBigInt(&b))
				// expectedJac.mulGLV(&g1Gen, sampleScalars[i].ToBigInt(&b))
				expected.FromW12(&expectedJac)
				if !result[i].Equal(&expected) {
					return false
				}
			}
			return true
		},
		genScalar,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

// ------------------------------------------------------------
// benches

func BenchmarkG1W12IsInSubGroup(b *testing.B) {
	var a G1W12
	a.Set(&g1Gen)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.IsInSubGroup()
	}

}

func BenchmarkG1AffineBatchScalarMul(b *testing.B) {
	// ensure every words of the scalars are filled
	var mixer fr.Element
	mixer.SetString("7716837800905789770901243404444209691916730933998574719964609384059111546487")

	const pow = 15
	const nbSamples = 1 << pow

	var sampleScalars [nbSamples]fr.Element

	for i := 1; i <= nbSamples; i++ {
		sampleScalars[i-1].SetUint64(uint64(i)).
			Mul(&sampleScalars[i-1], &mixer).
			FromMont()
	}

	for i := 5; i <= pow; i++ {
		using := 1 << i

		b.Run(fmt.Sprintf("%d points", using), func(b *testing.B) {
			b.ResetTimer()
			for j := 0; j < b.N; j++ {
				_ = BatchScalarMultiplicationG1(&g1GenAff, sampleScalars[:using])
			}
		})
	}
}

func BenchmarkG1W12ScalarMul(b *testing.B) {

	var scalar big.Int
	r := fr.Modulus()
	scalar.SetString("5243587517512619047944770508185965837690552500527637822603658699938581184513", 10)
	scalar.Add(&scalar, r)

	var doubleAndAdd G1W12

	b.Run("double and add", func(b *testing.B) {
		b.ResetTimer()
		for j := 0; j < b.N; j++ {
			doubleAndAdd.mulWindowed(&g1Gen, &scalar)
		}
	})

    /*
	var glv G1W12
	b.Run("GLV", func(b *testing.B) {
		b.ResetTimer()
		for j := 0; j < b.N; j++ {
			glv.mulGLV(&g1Gen, &scalar)
		}
	})
    */

}

func BenchmarkG1AffineCofactorClearing(b *testing.B) {
	var a G1W12
	a.Set(&g1Gen)
	for i := 0; i < b.N; i++ {
		a.ClearCofactor(&a)
	}
}

func BenchmarkG1W12Add(b *testing.B) {
	var a G1W12
	a.Double(&g1Gen)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.AddAssign(&g1Gen)
	}
}

func BenchmarkG1W12AddMixed(b *testing.B) {
	var a G1W12
	a.Double(&g1Gen)

	var c G1Affine
	c.FromW12(&g1Gen)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.AddMixed(&c)
	}

}

func BenchmarkG1W12Double(b *testing.B) {
	var a G1W12
	a.Set(&g1Gen)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.DoubleAssign()
	}

}

func fuzzW12G1Affine(p *G1W12, f fp.Element) G1W12 {
	var res G1W12
	res.X.Mul(&p.X, &f)
	res.Y.Mul(&p.Y, &f).Mul(&res.Y, &f)
	res.Z.Mul(&p.Z, &f)
	return res
}
