// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package cp8632

import (
	// "math"
	"math/big"
	"runtime"

	// "github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/ecc/cp8-632/fp"
	"github.com/consensys/gnark-crypto/ecc/cp8-632/fr"
	"github.com/consensys/gnark-crypto/internal/parallel"
)

// G1Affine point in affine coordinates
type G1Affine struct {
	X, Y fp.Element
}

// G1W12 is a point with fp.Element coordinates
type G1W12 struct {
	X, Y, Z fp.Element
}

// g1Proj point in projective coordinates
type g1Proj struct {
	x, y, z fp.Element
}

// -------------------------------------------------------------------------------------------------
// Affine

// Set sets p to the provided point
func (p *G1Affine) Set(a *G1Affine) *G1Affine {
	p.X, p.Y = a.X, a.Y
	return p
}

// ScalarMultiplication computes and returns p = a*s
func (p *G1Affine) ScalarMultiplication(a *G1Affine, s *big.Int) *G1Affine {
	var _p G1W12
	_p.FromAffine(a)
	_p.mulWindowed(&_p, s)
	p.FromW12(&_p)
	return p
}

// Add adds two point in affine coordinates.
// This should rarely be used as it is very inneficient compared to W12
// TODO implement affine addition formula
func (p *G1Affine) Add(a, b *G1Affine) *G1Affine {
	var p1, p2 G1W12
	p1.FromAffine(a)
	p2.FromAffine(b)
	p1.AddAssign(&p2)
	p.FromW12(&p1)
	return p
}

// Sub subs two point in affine coordinates.
// This should rarely be used as it is very inneficient compared to W12
// TODO implement affine addition formula
func (p *G1Affine) Sub(a, b *G1Affine) *G1Affine {
	var p1, p2 G1W12
	p1.FromAffine(a)
	p2.FromAffine(b)
	p1.SubAssign(&p2)
	p.FromW12(&p1)
	return p
}

// Equal tests if two points (in Affine coordinates) are equal
func (p *G1Affine) Equal(a *G1Affine) bool {
	return p.X.Equal(&a.X) && p.Y.Equal(&a.Y)
}

// Neg computes -G
func (p *G1Affine) Neg(a *G1Affine) *G1Affine {
	p.X = a.X
	p.Y.Neg(&a.Y)
	return p
}

// FromW12 rescale a point in W12 coord in z=1 plane
func (p *G1Affine) FromW12(p1 *G1W12) *G1Affine {

	var a, b fp.Element

	if p1.Z.IsZero() {
		p.X.SetZero()
		p.Y.SetZero()
		return p
	}

	a.Inverse(&p1.Z)
	b.Square(&a)
	p.X.Mul(&p1.X, &a)
	p.Y.Mul(&p1.Y, &b)

	return p
}

func (p *G1Affine) String() string {
	var x, y fp.Element
	x.Set(&p.X)
	y.Set(&p.Y)
	return "E([" + x.String() + "," + y.String() + "]),"
}

// IsInfinity checks if the point is infinity (in affine, it's encoded as (0,0))
func (p *G1Affine) IsInfinity() bool {
	return p.X.IsZero() && p.Y.IsZero()
}

// IsOnCurve returns true if p in on the curve
func (p *G1Affine) IsOnCurve() bool {
	var point G1W12
	point.FromAffine(p)
	return point.IsOnCurve() // call this function to handle infinity point
}

// IsInSubGroup returns true if p is in the correct subgroup, false otherwise
func (p *G1Affine) IsInSubGroup() bool {
	var _p G1W12
	_p.FromAffine(p)
	return _p.IsOnCurve() && _p.IsInSubGroup()
}

// -------------------------------------------------------------------------------------------------
// W12

// Set sets p to the provided point
func (p *G1W12) Set(a *G1W12) *G1W12 {
	p.X, p.Y, p.Z = a.X, a.Y, a.Z
	return p
}

// Equal tests if two points (in W12 coordinates) are equal
func (p *G1W12) Equal(a *G1W12) bool {

	if p.Z.IsZero() && a.Z.IsZero() {
		return true
	}
	_p := G1Affine{}
	_p.FromW12(p)

	_a := G1Affine{}
	_a.FromW12(a)

	return _p.X.Equal(&_a.X) && _p.Y.Equal(&_a.Y)
}

// Neg computes -G
func (p *G1W12) Neg(a *G1W12) *G1W12 {
	*p = *a
	p.Y.Neg(&a.Y)
	return p
}

// SubAssign substracts two points on the curve
func (p *G1W12) SubAssign(a *G1W12) *G1W12 {
	var tmp G1W12
	tmp.Set(a)
	tmp.Y.Neg(&tmp.Y)
	p.AddAssign(&tmp)
	return p
}

// AddAssign point addition in montgomery form
// https://hyperelliptic.org/EFD/g1p/auto-shortw-w12-0.html#addition-add-2010-cln
func (p *G1W12) AddAssign(a *G1W12) *G1W12 {

	// p is infinity, return a
	if p.Z.IsZero() {
		p.Set(a)
		return p
	}

	// a is infinity, return p
	if a.Z.IsZero() {
		return p
	}

	var tmp, A, B, C, D, E, F, G, H, I, II, J, K, JJ fp.Element
	A.Square(&a.Z)
	B.Square(&p.Z)
    C.Add(&a.Z, &p.Z).
        Square(&C).
        Sub(&C, &A).
        Sub(&C, &B)
    D.Mul(&a.X, &p.Z)
    E.Mul(&p.X, &a.Z)
    F.Mul(&a.Y, &B)
    G.Mul(&p.Y, &A)
    H.Sub(&D, &E)
    I.Sub(&F, &G).
        Double(&I)
    II.Square(&I)
    J.Mul(&C, &H)
    K.Mul(&J, &H).
        Double(&K).
        Double(&K)
    tmp.Add(&D, &E).
        Mul(&tmp, &K)

    p.X.Double(&II).
        Sub(&p.X, &tmp)

    JJ.Square(&J)
    tmp.Mul(&D, &K).
        Sub(&tmp, &p.X)

    p.Y.Add(&I, &J).
        Square(&p.Y).
        Sub(&p.Y, &JJ).
        Sub(&p.Y, &II).
        Mul(&p.Y, &tmp)

    tmp.Square(&K).
        Mul(&tmp, &F)

    p.Y.Sub(&p.Y, &tmp)

    p.Z.Double(&JJ)

	return p
}

// AddMixed point addition
// https://hyperelliptic.org/EFD/g1p/auto-shortw-w12-0.html#addition-madd-2010-cln
func (p *G1W12) AddMixed(a *G1Affine) *G1W12 {

	//if a is infinity return p
	if a.X.IsZero() && a.Y.IsZero() {
		return p
	}
	// p is infinity, return a
	if p.Z.IsZero() {
		p.X = a.X
		p.Y = a.Y
		p.Z.SetOne()
		return p
	}

    var q G1W12
    q.Set(p)

	var tmp, A, E, G, H, I, II, J, K, JJ fp.Element
    A.Square(&q.Z)
    E.Mul(&a.X, &q.Z)
    G.Mul(&a.Y, &A)
    H.Sub(&q.X, &E)
    I.Sub(&q.Y, &G)
    II.Square(&I)
    J.Mul(&q.Z, &H)
    K.Mul(&J, &H).
        Double(&K)
    tmp.Add(&q.X, &E).
        Mul(&tmp, &K)

    p.X.Double(&II).
        Sub(&p.X, &tmp)

    JJ.Square(&J)

    p.Y.Add(&J, &I).
        Square(&p.Y).
        Sub(&p.Y, &JJ).
        Sub(&p.Y, &II)

    tmp.Mul(&q.X, &K).
        Sub(&tmp, &p.X)

    p.Y.Mul(&p.Y, &tmp)

    tmp.Square(&K).
        Mul(&tmp, &a.Y)

    p.Y.Sub(&p.Y, &tmp)

    p.Z.Double(&JJ)

	return p
}

// Double doubles a point in W12 coordinates
// https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2007-bl
func (p *G1W12) Double(q *G1W12) *G1W12 {
	p.Set(q)
	p.DoubleAssign()
	return p
}

// DoubleAssign doubles a point in W12 coordinates
// https://hyperelliptic.org/EFD/g1p/auto-shortw-w12-0.html#doubling-dbl-2010-cln
func (p *G1W12) DoubleAssign() *G1W12 {

	var A, B, C, D, E, F fp.Element

    A.Square(&p.X)
    B.Square(&p.Y)
    C.Square(&p.Z)
    D.Neg(&C) // Mul by a=-1

    p.X.Sub(&A, &D).
        Square(&p.X)

    E.Add(&A, &D).
        Square(&E).
        Double(&E).
        Sub(&E, &p.X)
    F.Sub(&A, &D).
        Add(&F, &p.Y).
        Square(&F).
        Sub(&F, &B).
        Sub(&F, &p.X)

    p.Y.Mul(&E, &F)

    p.Z.Double(&B).
        Double(&p.Z)

	return p
}

// ScalarMultiplication computes and returns p = a*s
// see https://www.iacr.org/archive/crypto2001/21390189.pdf
func (p *G1W12) ScalarMultiplication(a *G1W12, s *big.Int) *G1W12 {
	return p.mulWindowed(a, s)
}

func (p *G1W12) String() string {
	if p.Z.IsZero() {
		return "O"
	}
	_p := G1Affine{}
	_p.FromW12(p)
	return "E([" + _p.X.String() + "," + _p.Y.String() + "]),"
}

// FromAffine sets p = Q, p in W12, Q in affine
func (p *G1W12) FromAffine(Q *G1Affine) *G1W12 {
	if Q.X.IsZero() && Q.Y.IsZero() {
		p.X.SetZero()
		p.Y.SetOne()
		p.Z.SetZero()
		return p
	}
	p.Z.SetOne()
	p.X.Set(&Q.X)
	p.Y.Set(&Q.Y)
	return p
}

// IsOnCurve returns true if p in on the curve
// y^2 = x^3 + a*x
// Y^2=Z*X^3-Z^3*X
// TODO: mul by a instead of neg
func (p *G1W12) IsOnCurve() bool {
	var left, right, tmp fp.Element
	left.Square(&p.Y)
	right.Square(&p.X).
        Mul(&right, &p.X).
        Mul(&right, &p.Z)
	tmp.Square(&p.Z).
		Mul(&tmp, &p.Z).
		Mul(&tmp, &p.X).
		Neg(&tmp)
	right.Add(&right, &tmp)
	return left.Equal(&right)
}

// TODO: optimize
// IsInSubGroup returns true if p is on the r-torsion, false otherwise.
func (p *G1W12) IsInSubGroup() bool {

    var res G1W12
    res.ScalarMultiplication(p, fr.Modulus())

	return res.IsOnCurve() && res.Z.IsZero()
}

// mulWindowed 2-bits windowed exponentiation
func (p *G1W12) mulWindowed(a *G1W12, s *big.Int) *G1W12 {

	var res G1W12
	var ops [3]G1W12

	res.Set(&g1Infinity)
	ops[0].Set(a)
	ops[1].Double(&ops[0])
	ops[2].Set(&ops[0]).AddAssign(&ops[1])

	b := s.Bytes()
	for i := range b {
		w := b[i]
		mask := byte(0xc0)
		for j := 0; j < 4; j++ {
			res.DoubleAssign().DoubleAssign()
			c := (w & mask) >> (6 - 2*j)
			if c != 0 {
				res.AddAssign(&ops[c-1])
			}
			mask = mask >> 2
		}
	}
	p.Set(&res)

	return p

}

/*
// phi assigns p to phi(a) where phi: (x,y)->(ux,y), and returns p
func (p *G1W12) phi(a *G1W12) *G1W12 {
	p.Set(a)
	p.X.Mul(&p.X, &thirdRootOneG1)
	return p
}

// mulGLV performs scalar multiplication using GLV
// see https://www.iacr.org/archive/crypto2001/21390189.pdf
func (p *G1W12) mulGLV(a *G1W12, s *big.Int) *G1W12 {

	var table [15]G1W12
	var zero big.Int
	var res G1W12
	var k1, k2 fr.Element

	res.Set(&g1Infinity)

	// table[b3b2b1b0-1] = b3b2*phi(a) + b1b0*a
	table[0].Set(a)
	table[3].phi(a)

	// split the scalar, modifies +-a, phi(a) accordingly
	k := ecc.SplitScalar(s, &glvBasis)

	if k[0].Cmp(&zero) == -1 {
		k[0].Neg(&k[0])
		table[0].Neg(&table[0])
	}
	if k[1].Cmp(&zero) == -1 {
		k[1].Neg(&k[1])
		table[3].Neg(&table[3])
	}

	// precompute table (2 bits sliding window)
	// table[b3b2b1b0-1] = b3b2*phi(a) + b1b0*a if b3b2b1b0 != 0
	table[1].Double(&table[0])
	table[2].Set(&table[1]).AddAssign(&table[0])
	table[4].Set(&table[3]).AddAssign(&table[0])
	table[5].Set(&table[3]).AddAssign(&table[1])
	table[6].Set(&table[3]).AddAssign(&table[2])
	table[7].Double(&table[3])
	table[8].Set(&table[7]).AddAssign(&table[0])
	table[9].Set(&table[7]).AddAssign(&table[1])
	table[10].Set(&table[7]).AddAssign(&table[2])
	table[11].Set(&table[7]).AddAssign(&table[3])
	table[12].Set(&table[11]).AddAssign(&table[0])
	table[13].Set(&table[11]).AddAssign(&table[1])
	table[14].Set(&table[11]).AddAssign(&table[2])

	// bounds on the lattice base vectors guarantee that k1, k2 are len(r)/2 bits long max
	k1.SetBigInt(&k[0]).FromMont()
	k2.SetBigInt(&k[1]).FromMont()

	// loop starts from len(k1)/2 due to the bounds
	for i := int(math.Ceil(fr.Limbs/2. - 1)); i >= 0; i-- {
		mask := uint64(3) << 62
		for j := 0; j < 32; j++ {
			res.Double(&res).Double(&res)
			b1 := (k1[i] & mask) >> (62 - 2*j)
			b2 := (k2[i] & mask) >> (62 - 2*j)
			if b1|b2 != 0 {
				s := (b2<<2 | b1)
				res.AddAssign(&table[s-1])
			}
			mask = mask >> 2
		}
	}

	p.Set(&res)
	return p
}
*/

// ClearCofactor maps a point in curve to r-torsion
func (p *G1Affine) ClearCofactor(a *G1Affine) *G1Affine {
	var _p G1W12
	_p.FromAffine(a)
	_p.ClearCofactor(&_p)
	p.FromW12(&_p)
	return p
}

// TODO: optimize
// ClearCofactor maps a point in E(Fp) to E(Fp)[r]
func (p *G1W12) ClearCofactor(a *G1W12) *G1W12 {

    p.ScalarMultiplication(a, &cofactor)

	return p
}

// -------------------------------------------------------------------------------------------------
// Homogenous projective

// Set sets p to the provided point
func (p *g1Proj) Set(a *g1Proj) *g1Proj {
	p.x, p.y, p.z = a.x, a.y, a.z
	return p
}

// Neg computes -G
func (p *g1Proj) Neg(a *g1Proj) *g1Proj {
	*p = *a
	p.y.Neg(&a.y)
	return p
}

// FromW12 converts a point from W12 to projective coordinates
func (p *g1Proj) FromW12(Q *G1W12) *g1Proj {
	var buf fp.Element
	buf.Square(&Q.Z)

	p.x.Mul(&Q.X, &Q.Z)
	p.y.Set(&Q.Y)
	p.z.Mul(&Q.Z, &buf)

	return p
}

// FromAffine sets p = Q, p in homogenous projective, Q in affine
func (p *g1Proj) FromAffine(Q *G1Affine) *g1Proj {
	if Q.X.IsZero() && Q.Y.IsZero() {
		p.z.SetZero()
		p.x.SetOne()
		p.y.SetOne()
		return p
	}
	p.z.SetOne()
	p.x.Set(&Q.X)
	p.y.Set(&Q.Y)
	return p
}

// BatchProjectiveToAffineG1 converts points in Projective coordinates to Affine coordinates
// performing a single field inversion (Montgomery batch inversion trick)
// result must be allocated with len(result) == len(points)
func BatchProjectiveToAffineG1(points []g1Proj, result []G1Affine) {
	zeroes := make([]bool, len(points))
	accumulator := fp.One()

	// batch invert all points[].Z coordinates with Montgomery batch inversion trick
	// (stores points[].Z^-1 in result[i].X to avoid allocating a slice of fr.Elements)
	for i := 0; i < len(points); i++ {
		if points[i].z.IsZero() {
			zeroes[i] = true
			continue
		}
		result[i].X = accumulator
		accumulator.Mul(&accumulator, &points[i].z)
	}

	var accInverse fp.Element
	accInverse.Inverse(&accumulator)

	for i := len(points) - 1; i >= 0; i-- {
		if zeroes[i] {
			// do nothing, X and Y are zeroes in affine.
			continue
		}
		result[i].X.Mul(&result[i].X, &accInverse)
		accInverse.Mul(&accInverse, &points[i].z)
	}

	// batch convert to affine.
	parallel.Execute(len(points), func(start, end int) {
		for i := start; i < end; i++ {
			if zeroes[i] {
				// do nothing, X and Y are zeroes in affine.
				continue
			}
			var a fp.Element
			a = result[i].X
			result[i].X.Mul(&points[i].x, &a)
			result[i].Y.Mul(&points[i].y, &a)
		}
	})
}

// BatchW12ToAffineG1 converts points in W12 coordinates to Affine coordinates
// performing a single field inversion (Montgomery batch inversion trick)
// result must be allocated with len(result) == len(points)
func BatchW12ToAffineG1(points []G1W12, result []G1Affine) {
	zeroes := make([]bool, len(points))
	accumulator := fp.One()

	// batch invert all points[].Z coordinates with Montgomery batch inversion trick
	// (stores points[].Z^-1 in result[i].X to avoid allocating a slice of fr.Elements)
	for i := 0; i < len(points); i++ {
		if points[i].Z.IsZero() {
			zeroes[i] = true
			continue
		}
		result[i].X = accumulator
		accumulator.Mul(&accumulator, &points[i].Z)
	}

	var accInverse fp.Element
	accInverse.Inverse(&accumulator)

	for i := len(points) - 1; i >= 0; i-- {
		if zeroes[i] {
			// do nothing, X and Y are zeroes in affine.
			continue
		}
		result[i].X.Mul(&result[i].X, &accInverse)
		accInverse.Mul(&accInverse, &points[i].Z)
	}

	// batch convert to affine.
	parallel.Execute(len(points), func(start, end int) {
		for i := start; i < end; i++ {
			if zeroes[i] {
				// do nothing, X and Y are zeroes in affine.
				continue
			}
			var a, b fp.Element
			a = result[i].X
			b.Square(&a)
			result[i].X.Mul(&points[i].X, &a)
			result[i].Y.Mul(&points[i].Y, &b)
		}
	})

}

// BatchScalarMultiplicationG1 multiplies the same base (generator) by all scalars
// and return resulting points in affine coordinates
// uses a simple windowed-NAF like exponentiation algorithm
func BatchScalarMultiplicationG1(base *G1Affine, scalars []fr.Element) []G1Affine {

	// approximate cost in group ops is
	// cost = 2^{c-1} + n(scalar.nbBits+nbChunks)

	nbPoints := uint64(len(scalars))
	min := ^uint64(0)
	bestC := 0
	for c := 2; c < 18; c++ {
		cost := uint64(1 << (c - 1))
		nbChunks := uint64(fr.Limbs * 64 / c)
		if (fr.Limbs*64)%c != 0 {
			nbChunks++
		}
		cost += nbPoints * ((fr.Limbs * 64) + nbChunks)
		if cost < min {
			min = cost
			bestC = c
		}
	}
	c := uint64(bestC) // window size
	nbChunks := int(fr.Limbs * 64 / c)
	if (fr.Limbs*64)%c != 0 {
		nbChunks++
	}
	mask := uint64((1 << c) - 1) // low c bits are 1
	msbWindow := uint64(1 << (c - 1))

	// precompute all powers of base for our window
	// note here that if performance is critical, we can implement as in the msmX methods
	// this allocation to be on the stack
	baseTable := make([]G1W12, (1 << (c - 1)))
	baseTable[0].Set(&g1Infinity)
	baseTable[0].AddMixed(base)
	for i := 1; i < len(baseTable); i++ {
		baseTable[i] = baseTable[i-1]
		baseTable[i].AddMixed(base)
	}

	pScalars := partitionScalars(scalars, c, false, runtime.NumCPU())

	// compute offset and word selector / shift to select the right bits of our windows
	selectors := make([]selector, nbChunks)
	for chunk := 0; chunk < nbChunks; chunk++ {
		jc := uint64(uint64(chunk) * c)
		d := selector{}
		d.index = jc / 64
		d.shift = jc - (d.index * 64)
		d.mask = mask << d.shift
		d.multiWordSelect = (64%c) != 0 && d.shift > (64-c) && d.index < (fr.Limbs-1)
		if d.multiWordSelect {
			nbBitsHigh := d.shift - uint64(64-c)
			d.maskHigh = (1 << nbBitsHigh) - 1
			d.shiftHigh = (c - nbBitsHigh)
		}
		selectors[chunk] = d
	}
	// convert our base exp table into affine to use AddMixed
	baseTableAff := make([]G1Affine, (1 << (c - 1)))
	BatchW12ToAffineG1(baseTable, baseTableAff)
	toReturn := make([]G1W12, len(scalars))

	// for each digit, take value in the base table, double it c time, voila.
	parallel.Execute(len(pScalars), func(start, end int) {
		var p G1W12
		for i := start; i < end; i++ {
			p.Set(&g1Infinity)
			for chunk := nbChunks - 1; chunk >= 0; chunk-- {
				s := selectors[chunk]
				if chunk != nbChunks-1 {
					for j := uint64(0); j < c; j++ {
						p.DoubleAssign()
					}
				}

				bits := (pScalars[i][s.index] & s.mask) >> s.shift
				if s.multiWordSelect {
					bits += (pScalars[i][s.index+1] & s.maskHigh) << s.shiftHigh
				}

				if bits == 0 {
					continue
				}

				// if msbWindow bit is set, we need to substract
				if bits&msbWindow == 0 {
					// add
					p.AddMixed(&baseTableAff[bits-1])
				} else {
					// sub
					t := baseTableAff[bits & ^msbWindow]
					t.Neg(&t)
					p.AddMixed(&t)
				}
			}

			// set our result point
			toReturn[i] = p

		}
	})
	toReturnAff := make([]G1Affine, len(scalars))
	BatchW12ToAffineG1(toReturn, toReturnAff)
	return toReturnAff
}

// selector stores the index, mask and shifts needed to select bits from a scalar
// it is used during the multiExp algorithm or the batch scalar multiplication
type selector struct {
	index uint64 // index in the multi-word scalar to select bits from
	mask  uint64 // mask (c-bit wide)
	shift uint64 // shift needed to get our bits on low positions

	multiWordSelect bool   // set to true if we need to select bits from 2 words (case where c doesn't divide 64)
	maskHigh        uint64 // same than mask, for index+1
	shiftHigh       uint64 // same than shift, for index+1
}

// partitionScalars  compute, for each scalars over c-bit wide windows, nbChunk digits
// if the digit is larger than 2^{c-1}, then, we borrow 2^c from the next window and substract
// 2^{c} to the current digit, making it negative.
// negative digits can be processed in a later step as adding -G into the bucket instead of G
// (computing -G is cheap, and this saves us half of the buckets in the MultiExp or BatchScalarMul)
// scalarsMont indicates wheter the provided scalars are in montgomery form
func partitionScalars(scalars []fr.Element, c uint64, scalarsMont bool, nbTasks int) []fr.Element {
	toReturn := make([]fr.Element, len(scalars))

	// number of c-bit radixes in a scalar
	nbChunks := fr.Limbs * 64 / c
	if (fr.Limbs*64)%c != 0 {
		nbChunks++
	}

	mask := uint64((1 << c) - 1)      // low c bits are 1
	msbWindow := uint64(1 << (c - 1)) // msb of the c-bit window
	max := int(1 << (c - 1))          // max value we want for our digits
	cDivides64 := (64 % c) == 0       // if c doesn't divide 64, we may need to select over multiple words

	// compute offset and word selector / shift to select the right bits of our windows
	selectors := make([]selector, nbChunks)
	for chunk := uint64(0); chunk < nbChunks; chunk++ {
		jc := uint64(chunk * c)
		d := selector{}
		d.index = jc / 64
		d.shift = jc - (d.index * 64)
		d.mask = mask << d.shift
		d.multiWordSelect = !cDivides64 && d.shift > (64-c) && d.index < (fr.Limbs-1)
		if d.multiWordSelect {
			nbBitsHigh := d.shift - uint64(64-c)
			d.maskHigh = (1 << nbBitsHigh) - 1
			d.shiftHigh = (c - nbBitsHigh)
		}
		selectors[chunk] = d
	}

	parallel.Execute(len(scalars), func(start, end int) {
		for i := start; i < end; i++ {
			var carry int

			scalar := scalars[i]
			if scalarsMont {
				scalar.FromMont()
			}

			// for each chunk in the scalar, compute the current digit, and an eventual carry
			for chunk := uint64(0); chunk < nbChunks; chunk++ {
				s := selectors[chunk]

				// init with carry if any
				digit := carry
				carry = 0

				// digit = value of the c-bit window
				digit += int((scalar[s.index] & s.mask) >> s.shift)

				if s.multiWordSelect {
					// we are selecting bits over 2 words
					digit += int(scalar[s.index+1]&s.maskHigh) << s.shiftHigh
				}

				// if the digit is larger than 2^{c-1}, then, we borrow 2^c from the next window and substract
				// 2^{c} to the current digit, making it negative.
				if digit >= max {
					digit -= (1 << c)
					carry = 1
				}

				var bits uint64
				if digit >= 0 {
					bits = uint64(digit)
				} else {
					bits = uint64(-digit-1) | msbWindow
				}

				toReturn[i][s.index] |= (bits << s.shift)
				if s.multiWordSelect {
					toReturn[i][s.index+1] |= (bits >> s.shiftHigh)
				}

			}
		}
	}, nbTasks)
	return toReturn
}
